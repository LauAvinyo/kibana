#!/bin/groovy

library 'kibana-pipeline-library'
kibanaLibrary.load() // load from the Jenkins instance

kibanaPipeline(timeoutMinutes: 240) {
  catchErrors {
    def timestamp = new Date(currentBuild.startTimeInMillis).format("yyyy-MM-dd'T'HH:mm:ss'Z'", TimeZone.getTimeZone("UTC"))
    withEnv([
      "TIME_STAMP=${timestamp}",
      'CODE_COVERAGE=1', // Enables coverage.  Needed for multiple ci scripts, such as remote.ts, test/scripts/*.sh, schema.js, etc.
    ]) {
      workers.base(name: 'coverage-worker', size: 'l', ramDisk: false, bootstrapped: false) {
//        kibanaCoverage.runTests()
//        handleIngestion(TIME_STAMP)
        if (params.NOTIFY_ON_FAILURE) {
          kibanaPipeline.bash("""
            echo '### params.NOTIFY_ON_FAILURE: true'
          """, '### Handle Notify on Failure')

          sendSlackMsg()
        }

      }
    }
    kibanaPipeline.sendMail()
  }
}

def handleIngestion(timestamp) {
  kibanaPipeline.downloadCoverageArtifacts()
  kibanaCoverage.prokLinks("### Process HTML Links")
  kibanaCoverage.collectVcsInfo("### Collect VCS Info")
  kibanaCoverage.ingest(timestamp, '### Injest && Upload')
  kibanaCoverage.uploadCoverageStaticSite(timestamp)
}

def sendSlackMsg(Map params = [:]) {
  def config = [
    channel: '#kibana-qa',
    title: "*<${env.BUILD_URL}|${slackNotifications.getDefaultDisplayName()}>*",
    message: slackNotifications.getDefaultDisplayName(),
    color: 'danger',
    icon: ':jenkins:',
    username: 'Kibana QA',
    context: slackNotifications.getDefaultContext(),
  ] + params

  def title = "${slackNotifications.getStatusIcon()} ${config.title}"

  def blocks = [slackNotifications.markdownBlock(title)]
  slackNotifications.getFailedBuildBlocks().each { blocks << it }
  blocks << slackNotifications.dividerBlock()
  blocks << config.context

  slackSend(
    channel: config.channel,
    username: config.username,
    iconEmoji: config.icon,
    color: config.color,
    message: config.message,
    blocks: blocks
  )
}

